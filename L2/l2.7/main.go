/* ВАРИАНТ №1 - решение задачи l2.7 */

package main

import (
	"fmt"
	"math/rand"
	"time"
)

// asChan возвращает канал, в который отдельная горутина из переданного
// слайса пишет числа через случайный промежуток времени
func asChan(vs ...int) <-chan int {

	c := make(chan int) // создаём канал

	// в отдельной горутине итерируемся по переданному в функцию слайсу
	// и с учётом time.Sleep пишем числа в канал
	go func() {
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}
		close(c) // закрываем канал после отправки всех значений
	}()

	return c // возвращаем канал для чтения
}

// merge объединяет два канала и возвращает один общий
func merge(a, b <-chan int) <-chan int {

	c := make(chan int) // создаём результирующий канал

	// в отдельной горутине в бесконечном цикле слушаем два канала в select.
	// select проверяет case в произвольном порядке
	go func() {
		for {
			select {
			case v, ok := <-a: // пробуем получить значение из канала a
				if ok {
					// если считываем не нулевое значение из закрытого канала, а реальное число
					c <- v // то отправляем его в результирующий канал c
				} else {
					// а если канал оказался закрыт и мы из него можем получить только нулевое значение
					// соответствующего типа, то выключаем ветку select приравниванием канала к nil (select игнорирует case с nil-каналами)
					a = nil
				}
			case v, ok := <-b: // пробуем получить значение из канала b
				if ok {
					// если считываем не нулевое значение из закрытого канала, а реальное число
					c <- v // то отправляем его в результирующий канал c
				} else {
					// а если канал оказался закрыт и мы из него можем получить только нулевое значение
					// соответствующего типа, то выключаем ветку select приравниванием канала к nil (select игнорирует case с nil-каналами)
					b = nil
				}
			}
			// если оба канала, которые сливаем, оказываются закрыты,
			// закрываем результирующий канал и завершаем горутину
			if a == nil && b == nil {
				close(c)
				return
			}
		}
	}()

	return c // возвращаем канал из функции
}

func main() {

	rand.Seed(time.Now().Unix()) // инициализируем генератор случайных чисел

	a := asChan(1, 3, 5, 7) // создаём один канал
	b := asChan(2, 4, 6, 8) // создаём второй канал
	c := merge(a, b)        // объединяем каналы

	// слушаем канал c пока он не будет закрыт
	for v := range c {
		fmt.Print(v)
	}
}
