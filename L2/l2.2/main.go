/* ВАРИАНТ №1 - решение задачи l2.2 */

/*
Порядок работы defer в Go:
1. Аргументы отложенной функции вычисляются немедленно, но вызов выполняется перед возвратом из функции.
2. Отложенные вызовы выполняются в порядке LIFO (последний добавленный — первый выполненный).
3. Если функция использует именованные возвращаемые значения, отложенная функция может изменять их после операции return.
*/

package main

import "fmt"

func test() (x int) {

	// аргумент отложенной функции вычислится только после return,
	// так как функция возвращает именованное значение
	defer func() {
		x++ // оператор увеличит значение x уже после того как x будет равен 1
	}()
	x = 1

	return // return возвращает x = 2 после выполнения defer

	/*
		Порядок:
		1. x = 1
		2. return (подготовка возвращаемого значения x = 1)
		3. вызов defer: x++, следовательно, x = 2
		4. функция возвращает 2
	*/
}

func anotherTest() int {

	var x int
	defer func() {
		x++ // изменение локальной переменной x (не возвращаемого значения)
	}()
	x = 1

	return x // return возвращает копию x = 1

	/*
		Порядок:
		1. x = 1
		2. return x - возвращаемое значение фиксируется как 1
		3. вызов defer: x++ (меняет локальную переменную x, но не возвращаемое значение)
		4. функция возвращает 1
	*/
}

func main() {

	// выводим в консоль значения переданные из функций
	fmt.Println(test())        // вывод: 2
	fmt.Println(anotherTest()) // вывод: 1
}
