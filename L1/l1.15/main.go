/* Пояснения и решение по коду из условия */

package main

import (
	"strings"
)

/*

Согласно приведённому в условии коду

var justString string

func someFunc() {

	v := createHugeString(1 << 10)	// создаём большууую строку (1024 символа, если однобайтная кодировка)
	justString = v[:100]			// ссылаемся на первые 100 символов v
}

func main() {
	someFunc()
}

глобальная переменная justString будет ссылаться на v и удерживать в памяти всю большую исходную строку, то есть
около 9/10 памяти под переменную будет испольоваться, чтобы таскать кусок строки, который не используется.
Данное явление можно отнести к примеру утечки памяти.

Решается вопрос такой утечки явным копированием данных.
*/

var justString string

func someFunc() {

	v := createHugeString(1 << 10)       // создаём большууую строку (1024 символа, если однобайтная кодировка)
	justString = string([]byte(v[:100])) // создаём новую строку 100 первых байт от v

	// или
	// bufer := make([]byte, 100)
	// copy(bufer, v[:100])
	// justString = string(bufer)

	/*
	   Преобразование []byte(string) и string([]byte) в Go всегда создает копию данных, а не делится памятью. Это гарантирует, что новая строка будет независимой.
	   В итоге исходная строка v может быть собрана сборщиком мусора сразу после этого преобразования, даже если justString продолжает использоваться.
	*/
}

func main() {
	someFunc()
}

// предположим, что createHugeString выглядит так
func createHugeString(size int) string {
	return strings.Repeat("x", size) // создаем строку из повторяющегося символа
}
