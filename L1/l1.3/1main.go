/* ВАРИАНТ №1 - абсолютно некорректное решение (неопределённое поведение и нет контроля остановки горутин) */

/*
Примечание: решение приведено как пример того, как делать точно не стоит.
*/

package main

import (
	"fmt"
)

const n = 5 // необходимое количество воркеров

// worker слушает канал и печатает то, что по нему приходит
func worker(ch chan any) {

	for v := range ch {
		fmt.Println(v)
	}
}

func main() {

	// создаём буферизированный канал
	in := make(chan any, n)

	// запускаем n воркеров
	for i := 0; i < n; i++ {
		go worker(in)
	}

	// пишем числа в канал и ждём вывода в консоль.
	// в условии задачи сказано "реализовать постоянную запись данных в канал", но для наглядности ограничимся некоторым числом.
	// при малом количестве итераций (<n) воркеры не успевают обработать данные + мы получаем какое-то количество ждущих горутин.
	// при достаточно большом количестве итераций ситуация ещё хуже - воркеры успевают печатать числа и можно подумать, что всё в
	// порядке, но количество выведенных чисел скорее всего не будет равно количеству итераций.
	for i := 0; i < 10000; i++ {
		in <- i
	}
}
