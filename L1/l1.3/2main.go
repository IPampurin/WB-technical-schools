/* ВАРИАНТ №2 - базовая реализация с бесконечной записью, остановкой по Ctrl + C и утечкой горутин */

/*
Примечание: решение согласно заданию, но стоит отметить, что если мы запустим программу, то через
			какое-то время, вероятно, возникнет желание её остановить, для чего придётся воспользоваться
			сочетанием Ctrl + C и в результате такой остановки процесса мы получим то, что называется утечкой горутин.
*/

package main

import (
	"fmt"
	"sync"
)

const n = 5 // необходимое количество воркеров

// worker печатает в консоль значение, полученное из канала
func worker(ch chan int, wg *sync.WaitGroup) {

	// вычитаем счётчик WaitGroup в любом случае
	defer wg.Done()

	// слушаем канал и печатаем то, что пришло
	for v := range ch {
		fmt.Println(v)
	}
}

func main() {

	// организуем счётчик WaitGroup
	var wg sync.WaitGroup

	// in канал для записи чисел
	in := make(chan int, n)

	// запускаем воркеры
	for i := 0; i < n; i++ {
		wg.Add(1) // прибавляем счётчик
		go worker(in, &wg)
	}

	number := 0

	// бесконечно шлём числа в in
	for {
		in <- number
		number++
	}

	// код ниже никогда не выполнится
	close(in) // закрываем канал
	wg.Wait() // ждём завершения горутин
}
